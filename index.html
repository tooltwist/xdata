<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Xdata by tooltwist</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Xdata</h1>
        <p>Cross Data converter and in-process transport format</p>

        <p class="view"><a href="https://github.com/tooltwist/xdata">View the Project on GitHub <small>tooltwist/xdata</small></a></p>


        <ul>
          <li><a href="https://github.com/tooltwist/xdata/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/tooltwist/xdata/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/tooltwist/xdata">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>What</h2>

<p>XData (aka <em>Cross Data</em>) is an "arbitrary data format" library for Java, allowing data to be passed around within a multi-layered Java application without concern for whether it's in XML, JSON, or some other format.</p>

<p><img src="https://raw.github.com/tooltwist/xdata/master/docs/images/basic-idea-1.jpeg" alt="https://raw.github.com/tooltwist/xdata/master/docs/images/basic-idea-1.jpeg"></p>

<h4>Documentation</h4>

<p><a href="https://github.com/tooltwist/xdata/wiki">XData Wiki</a><br><a href="https://groups.google.com/forum/?fromgroups#!forum/xdata-tooltwist">XData Group</a>  </p>

<h2>Why</h2>

<p>In an application architecture where a website is constructed by assembling components, the source of the data is not known at the time the UI components are written. A UI component may be used in many applications with many data sources, and there's no way of knowing the format of those various data sources at the time the UI component is written. XData allows such components to be developed without consideration for whether data will be provided as XML, JSON, or some other format.</p>

<p>Similarly, the code to access data may not know the format expected by other code that consumes that data.</p>

<p>XData provides a format-neutral mechanism for passing around data, but a consistent API for accessing data. For example, the following XPath-like code can be used to access both XML and JSON data.</p>

<pre><code>XD data = getCountryData();
for (XD state : data.select("/*/state")) {
    System.out.println("State is " + state.getString("name"));
}
</code></pre>

<p>XData also allows access to object representations of data (e.g. XML as DOM), with automatic conversions transparently performed as required.</p>

<h2>Mapping</h2>

<p>In many cases, the source of data may use different field names to the consumer of that data, even though the values are acceptable. For example, a graph UI component might display X versus Y, but a data source provides <em>lengthOfHair</em> versus <em>lengthOfMoustache</em>. XData allows a simple mapping of field names between the source and the time the data is accessed, including the ability to access nested data.</p>

<pre><code>person/lengthOfHair -&gt; graph/x
person/lower_face_information/lengthOfMoustach -&gt; graph/y
</code></pre>

<h2>Fast Parser</h2>

<p>XData also provides <em>fast parsing</em> to give improved performance in cases where the data is large. Typical XML and JSON parsers convert input data from string format into an object representation of the data (e.g. DOM). While this provides flexibility, it can result in a lot of instantiation and garbage collection overhead, creating objects for every element in the document, when typically only part of the data may be required.</p>

<p>XData's <em>fast parsing</em> creates an index over the string representation of the document which is then used to cherry pick specific data values. In some applications, such as accessing large data sets over a Restful interface, this approach can be about ten times faster than common parsers, once garbage collection cost is taken into account. Take a look at the benchmarks section in the wiki for an understanding of where this is appropriate.</p>

<h2></h2>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/tooltwist">tooltwist</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>